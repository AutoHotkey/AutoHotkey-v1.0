<head>
<title>AutoHotkey Change Log</title>
</head>
<body>
<font size=5>AutoHotkey Change Log
<br>
<br>

</font><font size=4><b>0.215 BETA - December 18, 2003</b></font><font size=3><br><br>

Fixed a possible crash in variable assignments that involve more than one source.  e.g. statements such as clipboard = %clipboard%%SomeVar%<br>
<br>
Fixed a possible crash-on-startup bug introduced in version 0.212 in conjuction with "else if" support.<br>
<br>
Fixed clipboard being hogged (held open) in rare cases such as displaying the clipboard with SplashTextOn.<br>
<br>
Fixed PixelGetColor to accept negative coordinates without complaining.<br>
<br>
Fixed a very obscure issue where a non-suppressed mouse hotkey such as "~LButton::" would cause that particular AutoHotkey instance's tray menu and main window context menus to behave strangely.<br>
<br>
Added command SoundSetWaveVolume, which sets the playback volume for files such as WAV and MP3.  Example:<br>
SoundSetWaveVolume, 50  ; Number between 0 and 100, inclusive.<br>
<br>
Added command EnvSet, which is needed because unlike AutoIt2, AutoHotkey does not store its variables in the environment.  This is because performance would be worse and also because the OS limits env. vars to 32K (AutoHotkey vars, including the clipboard, are essentially unlimited in size).  ErrorLevel is set to 1 if there was a problem or 0 otherwise.  Example:<br>
EnvSet, AutGUI, Some text to put in the variable.<br>
<br>
Note: An EnvGet command is not necessary because dereferencing a blank or undefined variable will automatically trigger that behavior.  For example, in the following line, the value of the ProgramFiles variable (if undefined in the script) will be fetched from the environment:<br>
TargetFile = %ProgramFiles%\Something\setup.ini<br>
<br>
Disabled the feature that jumps to the proper line in notepad or metapad when a syntax error is found (if the script is already open in such an editor) because it doesn't seem to work reliably.  If any of you were using it, let me know.  Later, I plan to add support for an external script such as "RunWhenSyntaxError.ahk" that will automatically be run if a script launch fails due to a syntax error.<br>
<br>
Improved PixelSearch to set ErrorLevel to 2 if there was an error other than "color not found".  It still sets it to 1 if the color isn't found, or 0 if it is.<br>

 
<br><hr><br>


</font><font size=4><b>0.214 BETA - December 16, 2003</b></font><font size=3><br><br>

Added command WinMenuSelectItem (similar to AutoIt3 command).  The menu search terms are not case sensitive (i.e. File->Save is the same as file->save) and the use of ampersand (&) to indicate the underlined letter in a menu item is not necessary.  Example:<br>
WinMenuSelectItem, Untitled - Notepad, , File, Save<br>
WinMenuSelectItem, Untitled - Notepad, , 1&, 3&  ; Same as above but uses menu item position rather than text.<br>
Note: The position method exists to support menus that don't contain text (perhaps because they are pictures of text rather than actual text?)  Position 1 is the first menu item (e.g. the File Menu).  Menu separator lines count as menu items for the purpose of determining the position of a menu item.<br>
<br>
Added command ControlFocus.  Example:<br>
ControlFocus, (ControlName or ControlClassNN), WinTitle, WinText, Excludetitle, Excludetext<br>
Note: As with all commands that take WinTitle/Text, you can specify the letter A as the title to use the active window, or leave all 4 window params blank to use the window most recently found by commands such as IfWinExist and WinWait.<br>
<br>
Improved the following commands so that they set ErrorLevel to 1 if there was any kind of non-critical error (such as a non-existent window or control) that prevented the command from completing:<br>
<PRE>
	ControlSend
	ControlLeftClick
	ControlSetText
	ControlGetText
	StatusBarGetText
	WinGetText
</PRE>
<br>
Improved StatusBarWait so that it sets ErrorLevel to 2 if there was some kind of error (e.g. the target window doesn't exist or doesn't have a status bar).  But as before, ErrorLevel will be set to 1 if the command times out or 0 if the status bar becomes a match for the specified text.<br>
<br>
Improved the KeyLog command to support logging keys & mouse buttons to a file.  It still works the old way (displaying the keylog window) if no params are given.  But it behaves differently if given a first param.  Examples:<br>
<PRE>
KeyLog, C:\Keylog.txt  ; Specify the filename and turn on file logging.
KeyLog, off     ; Turn off file logging.
KeyLog, on      ; Turn on file logging to the filename specified by a prior use of this command.
Keylog, toggle  ; Toggle logging (set it to the opposite of its previous state).
</PRE>
The keyboard or mouse hook must be installed for logging to occur.  You can force them to be unconditionally installed by adding the following lines to your script:<br>
#InstallKeybdHook<br>
#InstallMouseHook<br>
<br>
The log file a tab-delimited text file with the following fields:<br>
Virtual key code (hex)<br>
Scan code (hex, the first digit is 1 if the key is an "extended" key)<br>
Seconds elapsed since prior event<br>
flag (h = hook hotkey, s = suppressed (hidden from system) by hook, i = ignored by hook)<br>
down/up (d or u)<br>
Key name<br>
Active window title (only present if it has changed from the prior event)<br>
<br>
Sample log file:<br>
<PRE>
59	015	15.0	 	u	Y	C:\
5B	15B	0.1	 	u	Left Windows
9E	000	1.1	 	d	WheelDown
9F	000	0.4	 	d	WheelUp
A4	038	0.4	 	d	Alt
09	00F	0.1	 	d	Tab
09	00F	0.2	 	u	Tab
A4	038	0.1	 	u	Alt	 Untitled - Notepad
A3	11D	1.4	 	d	Right Ctrl
26	148	0.1	h	d	Up	C:\
26	148	0.1	s	u	Up
A3	11D	0.0	 	u	Right Ctrl
A3	11D	1.6	 	d	Right Ctrl
2E	153	0.1	h	d	Delete
A3	11D	0.0	i	u	Right Ctrl
A4	038	0.0	i	d	Alt
73	03E	0.0	i	d	F4
73	03E	0.0	i	u	F4
A4	038	0.0	i	u	Alt
A3	11D	0.0	i	d	Right Ctrl
</PRE>
Note: Each keystroke generates two lines, a down and an up.<br>

 
<br><hr><br>


</font><font size=4><b>0.213 BETA - December 15, 2003</b></font><font size=3><br><br>
 
Fixed hotkeys that have LWin/RWin (windows key) as a modifier and that use the Send command: In some cases, the windows key was incorrectly put into the down position after the Send.  [Thanks to Robert Yaklin for discovering this.]  On a related note, you do not need to use the Sleep command to allow the user time to release the modifier keys (Ctrl/Alt/Shift/Win) with hotkeys that use the Send command.  The Send command knows to change the modifiers to what they need to be for every key that will be sent.<br>
<br>
Fixed hotkeys that override Windows hotkeys such as Win-E and Win-R so that the Start Menu doesn't appear when the Windows key is released.<br>
<br>
Added PixelGetColor and PixelSearch, which mirror AutoIt3's commands of the same name.  These can help with detecting the state of non-standard controls and with the automation of full-screen apps such as games.  See docs for details.<br>
<br>
Minor: Undid the previous change mentioned below having to do with "escape chars at the end of a line or that escape a whitespace char".  To conform to AutoIt2 behavior, escape chars that don't escape anything are now removed (i.e. made invisible).<br>
<br>
Minor: Changed WinClose to use the WM_CLOSE vs. SC_CLOSE (alt-F4) method so that it's like AutoIt2 and AutoIt3.  The new method is a little less gentle to the target window than the previous method, but it's likely to work on more types of windows.<br>
<br>
There's now an automated way to convert a .aut file to .ahk so that you can take full advantage of the new features (some new features -- such as the new params available in some commands -- are disabled in .aut scripts to improve compatibility with AutoIt2).  The conversion will simply make the escape character ` instead of \.  This is harder than it sounds due to the precise ordering of escape sequences in each line, which is why you just can't do a Search & Replace in a text editor.  This automated way should take care of all the details:<br>
1) Append a .ahk to the end of an existing .aut file, so that filename now ends in ".aut.ahk"<br>
2) Run this file with AutoHotkey, which, rather than than running the file, will create a new file in the same directory that ends in "-NEW.ahk".  This is the converted version.  The original version will be unchanged.<br>
3) If you were using #DerefChar in the script, remove it from the converted version.<br>
<br>
After converting a script from .aut to .ahk, the main problem areas to check for are commands that accept additional params in .ahk files but not in .aut files.  If you used any non-escaped commas in the param that was formerly the last param (in AutoIt2) but is now not the last param, those commas will be interpreted as delimiters.<br>
<br>
Example:<br>
Msgbox, 0, Title, Text, with, commas<br>
<br>
In the above, the string "Text, with, commas" would be interpreted as the last arg by AutoIt2.  But since AutoHotkey supports a new param for the timeout of the MsgBox, the string "with, commas" would be interpreted as the timeout value (which would be caught as a load-time error in this case).<br>
<br>
Example #2:<br>
WinActivate, title, text with literal comma, here.<br>
<br>
The above would be a problem after conversion; The string "here." would be interpreted as the new "exclude title" param.<br>
<br>
Here is a list of commands that both accept new params and that might be problematic:<br>
MsgBox<br>
StringReplace<br>
StringGetPos<br>
WinClose/Kill/Activate/Minimize/Maximize/Restore/Hide/Show<br>
WinSetTitle/WinGetTitle<br>
<br>
Note #1: Even though they accept new params in .ahk files, commands such as IfWinExist are not troublesome with respect to the above because the program can tell the difference between the AutoIt2 and AutoHotkey methods.  The WinWait family of commands should also not be a problem.<br>
<br>
Note #2: As always, AutoHotkey can run most AutoIt2 (.aut) files directly, without the need to convert to a .ahk file.<br>
 
<br><hr><br>


</font><font size=4><b>0.212 BETA - December 8, 2003</b></font><font size=3><br><br>

Added support for a command being on the same line as its ELSE.  Examples:<br>
<PRE>
if x = 1
	Gosub, a1
else if x = 2
	Gosub, a2
else IfEqual, x, 3
{
	Gosub, a3
	Sleep, 1
}
else Gosub, a4  ; i.e. Any command can be on the same line with an ELSE.
 
;Also OK:
IfEqual, y, 1, Gosub, b1
else {
	Sleep, 1
	Gosub, b2
}
 
; But this is illegal:
if x = 1 {  ; Invalid: This would compare X to the string "1 {" instead of treating { as the start of a block.
	Sleep, 1
	MsgBox, test
}
 
; A legal alternative:
IfEqual, x, 1, {
	Sleep, 1
	MsgBox, test
}
</PRE>
 
The main use of the above is for "else if" ladders, which may increase the script's readability.<br>
<br>
<br>
Relaxed the conditions that triggered the warning dialog "More than X hotkeys have been received in the last Y milliseconds" (thanks to CyberSlug for the idea) so that keyboard auto-repeat feature can be used on most systems without triggering a warning.  In addition, you can customize this behavior by using the following directives:<br>
<br>
#HotkeyInterval 2000       ; This is the default value (milliseconds).<br>
#MaxHotkeysPerInterval 50  ; This is the default value.<br>
<br>
Care should be taken not to make the above too lenient because if you ever inadvertently introduce an infinite loop of keystrokes (via a Send command that accidentally triggers other hotkeys), your computer could become unresponsive due to the rapid flood of keyboard events.  Example of an infinite loop of keystrokes: ^c::Send, ^c<br>
<br>
If you want to do something like the above without triggering an infinite loop add a $ to the hotkey definition (e.g $#y::).  The $ tells it to use the hook for the hotkey, which is smart enough to know not to treat our own SEND commands as a source for hotkeys.  Using the hook has at least a couple of disadvantages, which is why it isn't always used: 1) Only one instance of the program at a time should have the hook installed; 2) It may very slightly impact system performance.<br>
<br>
<br>
Improved the ~ (tilde) hotkey prefix (see docs) so that it works with modified hotkeys (i.e. those that require CTRL, ALT, SHIFT, or WIN to be pressed) as well as unmodified ones.  The only exception is mouse buttons, which must be unmodified to be "non-suppressed".<br>
<br>
Made all windowing commands support the letter A as the first param to indicate that the active window should be used.  Even though the result is always "known" ahead of time for commands such as WinWait, WinActivate, IfWinExists, and IfWinActive (since by definition the active window is active and exists), this change makes things more consistent.  For example, the first param can conditionally resolve to the letter A at runtime, thus increasing flexibility.  In addition, this change also allows the Last Used Window to be reset easily such as in this example:
<PRE>
#y::  ; Win-Y
Run, notepad
WinWait, Notepad
WinActivate  ; Activate the window last found.
; ...Let's say some time has passed and we're no longer sure which window is the "last used" one.
WinActivate, Notepad
WinWait, a  ; ***** Set the "last used" window to be the active window.
; Now we can do commands such as the below without specifying the window (better performance too):
WinMinimize
ControlSend, , Some text that will appear in notepad even if it isn't active (ControlSend can use the "last used" window; in addition it sends to the top-most control by default).
WinMaximize
WinActivate
return
</PRE>
<br>
New command:<br>
#HotkeyModifierTimeout 100  ; value in milliseconds, default 100<br>
The above only has meaning if the script does not have the keyboard hook installed (you can see if your script uses the hook via the KeyLog command).  This is because the hook can keep track of which modifier keys (ALT/CTRL/WIN/SHIFT) the user is physically holding down.  Example:<br>
^!a::Send, abcdefg<br>
The above SEND requires that CTRL and ALT be released so that the keys get sent properly.  After the SEND completes, if the hook is installed the program knows whether it can safely push back down CTRL and ALT.  But if not and the SEND finishes more than HotkeyModifierTimeout milliseconds after the hotkey subroutine began, the modifier keys will not be restored and you will have to release and press them again if you wish to use them to modify the same (or another) key again.  Note: You can set the value to be -1 so that it never times out, or 0 so that it always times out.  Also, you can ensure that the keyboard hook is installed, thus making the above unnecessary, by adding the line #InstallKeybdHook anywhere in the script.  Reducing KeyDelay (via SetKeyDelay) to 0 or -1 may also help if the keyboard hook isn't installed, since SEND will run more quickly.<br>
<br>
Fixed unjustified warning dialog ("Another instance of this program already has the keyboard or mouse hook installed") that occurred sometimes when using the "Reload This Script" function.  This was apparently caused by OS being slow to unload the prior instance & mutex from memory.  The program now does not display this warning if a currently-running script is being restarted.<br>
<br>
Added $ as a hotkey modifier symbol (e.g. $^c): It results in the use of an alternate (more powerful) method to implement the hotkey.  Use this if the default method doesn't work properly (due to its recursive use of the Send command, for example).  In technical terms, this method uses the keyboard hook rather than RegisterHotkey() to implement the hotkey.<br>
<br> 
Fixed GetKeyState so that all keys work.  Previously, keys with NumPad equivalents, such as Delete and End, didn't work.<br>
<br>
GetKeyState now supports an optional 3rd arg that can be the letter T (state of toggleable key such as CapsLock) or P (physical state of key).  If the arg is omitted or blank, the logical state of the key will be returned.  The logical state should be one that the OS and the foreground app believe the key to be in, whereas the physical state is whether the key or mouse button is physically down or up.  Example:<br>
GetKeyState, state, CapsLock, T  ; Will set "state" to be D if CapsLock is ON or U otherwise.<br>
<br>
Currently the "physical" state is always the same as the logical state if the hooks aren't installed, because Windows XP (and probably NT/2k, but perhaps not Win9x) doesn't seem to properly implement the following code.  If anyone has a workaround, I'd love to hear it:<br>
#define IsPhysicallyDown(vk) (GetAsyncKeyState(vk) & 0x80000000)<br>
<br> 
The keyboard hook is installed to support left/right-modifier specific hotkeys, wildcard hotkeys, SetNum/Scroll/CapsLock, AlwaysOn/Off, to override Windows Explorer hotkeys such as Win-E, and for a few other purposes.  It is not unconditionally installed because it very slightly impacts system performance and is also only not designed to be used by more than one script at a time (though you can force it).  You can determine which  hooks (mouse and keyboard) are installed by assigning the KeyLog command to a hotkey.<br>
<br>
You can force the hooks to be installed unconditionally by adding either or both of these lines anywhere in the script:<br>
#InstallKeybdHook  ; this is the hook needed to maximize reliability of modifier restoration with the Send command (see above)<br>
#InstallMouseHook  ; this would probably only be used if you wanted to see mouse button events in the KeyLog, since it will automatically be installed if you are using any mouse hotkeys<br>
<br>
<br>
For the Send command, changed the name of ControlDown/Up to CtrlDown/Up so that it matches AutoIt.  Also added LCtrl and RCtrl as alternate valid key names for LControl/RControl for use with hotkeys as well as commands such as Send and GetKeyState.<br>
<br>
Fixed SEND so that if modifier keys are sent that happen to be part of the hotkey definition itself, those modifiers are restored after the Send is complete.  This resolves issues where if KeyDelay was greater than -1, you would have to release the modifiers and press them down again to get the same hotkey to fire again after the first time. Example:<br>
^+0::Send, {SHIFTDOWN}a{SHIFTUP}<br>
Another thanks to CyberSlug for discovering this problem.  See other sections above for further details.<br>
<br>
Changed ControlSend so that {ASC nnnn} items are ignored, since the OS does not support this feature when sending keystrokes directly to a window or control.<br>
<br>
Fixed the Send command, which was sometimes sending an incorrect scan code (usually inconsequential).<br>
<br>
Minor change: A modifier's key-up hotkey action (if it has one) won't fire if that modifier was used to modify any mouse button click (since Ctrl-LeftClick, for example, is a valid native OS feature that most users would never want to sacrifice).<br>
<br>
Minor change: Escape characters that occur at the very end of a line or that "escape" a whitespace character are now considered to be literal.  This should be more like AutoIt2.  Example:<br>
var1 = this character is now literal -->`<br>
<br>
Tip: C-style section comments can be used, but the symbols must appear at the beginning of a line to be recognized:<br>
/*<br>
...<br>
(section that is commented out)<br>
...<br>
*/<br>


<br><hr><br>
 
</font><font size=4><b>0.211 BETA - December 1, 2003</b></font><font size=3><br><br>
 
Fixed the Reload command and the corresponding tray menu item to work with script filenames that contain spaces.<br>
<br>
Added GetKeyState.  Example:<br>
GetKeyState, OutputVar, LButton<br>
It sets OutputVar to be U (for up), D (for down), or blank if the state couldn't be determined for any reason.
The key name can be virtually any of the keys listed in the documentation, including mouse buttons (at least under WinXP, and they will probably work on other OSes as well).<br>
<br>
Added a new optional param to MouseClick.  If this last param is D the button will be held down until it is released by the user physically clicking it or via another action in the script.  If this last param is U, the button will be released (even if it wasn't down before, an up-event will still be sent).<br>
<br>
Added new hotkey definition symbol ~ (tilde) to indicate that this hotkey's native function shouldn't be suppressed (hidden from the system) when the hotkey fires.  For example, in the below, the mouse button click will be sent to the active window when it normally wouldn't be:<br>
~RButton::Sleep, 1<br>
Note: Special hotkeys that are substitutes for alt-tab always ignore this setting.<br>
<br>
Changed commands that click the mouse (MouseClick, LeftClick, etc.) so that the clicks themselves cannot trigger hotkey subroutines.  This prevents potential infinite loop conditions if a script were to send mouse events that happen to be valid hotkeys.<br>
<br>
Changed slightly how hotkeys that are combinations of keyboard and mouse work: Normally if the prefix key of that pair modifies any other key (even something that isn't a hotkey) its key-up action won't fire (if it has one).  This has been changed so that mouse buttons are the exception.  For example:<br>
Numpad0 & Numpad1::MsgBox, test1  ; Numpad0 is now a prefix key that is handled by the keyboard hook.<br>
Numpad0::MsgBox, test2 ; Now Numpad0 is both a prefix AND a suffix (a suffix because it has its own action)<br>
Under the old method, if Numpad0 was pressed down and then a mouse button clicked, the Numpad0 action would not fire when Numpad0 is released, as it normally would.  Under the new method it does, but only if the combination of Numpad0 and that mouse button isn't a hotkey (since by default, the key/mouse events that comprise a hotkey are always hidden from the system unless the ~ symbol, described above, is used).<br>
 
 
<br><hr><br>

</font><font size=4><b>0.210 BETA - November 19, 2003</b></font><font size=3><br><br>

Added command "suspend".  It's just like the tray menu item of the same name.  The first param can be either blank (to toggle the state to the opposite setting), ON (to suspend hotkeys), or OFF (to resume).  Note: Any hotkey whose subroutine's first line is the "suspend" command will not be subject to suspension.  This allows any such hotkey to turn off the suspension.<br>
 
<br><hr><br>

</font><font size=4><b>0.209 BETA - November 19, 2003</b></font><font size=3><br><br>

Improved Run and RunWait so that they attempt CreateProcess() (the AutoIt method) if the normal ShellExecute() method fails to work.  This should make things more flexible and more like AutoIt.  Note: Internally, the ShellExecute() method is always attempted first because I believe it has more capabilities, such as the ability to run documents, launch URLs, and execute system verbs such as "properties" (see below).<br>
 
Run and RunWait now support the following system verbs: properties, edit, print, find, explore, open, and print.  Example:<br>
Run, properties c:\autoexec.bat  ; Bring up the properties dialog for this file.<br>
Run, edit %A_SCRIPTFULLPATH%  ; Perform the associated "edit" action for this file (if it has one).<br>
<br>
Added #Delimiter command.  This can be used to change to the default (comma) delimiter, which is used to separate commands and params from each other.  Note: It cannot be a space, tab (since some editors replace tabs with spaces), or a char that it already in use for another special purpose.  Example:<br>
#delimiter . ; Make the delimiter a period rather than a comma.<br>
<br>
Fixed tray menu item "Edit This Script" (again) because it still wasn’t working right.<br>
<br>
Enabled tray menu item "Suspend".  This function prevents new hotkey subroutines from launching (but Alt-Tab hotkeys will still work).  In other words, pressing a hotkey will have no effect at all; it won’t even be seen by the system.   For example, if Control-C is a hotkey, it would do nothing rather than its normal "copy" behavior.  Note: “Suspend” will not halt any subroutines that are already running.<br>
 
 
 
<br><hr><br>

</font><font size=4><b>0.208 BETA - November 17, 2003</b></font><font size=3><br><br>

<b>FIXES:</b><br>
Fixed the tray menu item "Edit This Script".<br>
<br>
Fixed compatibility-check for AutoIt2: some of the default AutoIt2 behaviors weren't being used.<br>
<br>
Fixed WinWait commands: Exclude-Text and Exclude-Title weren't being handled correctly.<br>
<br>
Turned off debug logging: If you were running an older version, you may have a small text file “C:\AutoHotkey SetForegroundWindowEx.txt”, which you can safely delete after upgrading to this version.<br>
<br>
Changed StringReplace so that it doesn't trim whitespace from the result, which matches AutoIt2's behavior.<br>
<br>
<br>
<b>CHANGES:</b><br>
Included the VC++ project in the source code ZIP file.<br>
<br>
Changed the default for .aut (AutoIt2) scripts to "DetectHiddenWindows, off", so that things are more like AutoIt2.  This is now the default for all scripts.  From what I can tell, unlike AutoIt2, AutoIt3 always detects hidden windows.  Since this can sometimes cause problems with window matching and distinctness, the AutoIt2 method seems to be a better default.<br>
<br>
Changed the SetTitleMatchMode command.  In addition to supporting the traditional modes of 1 & 2, the command now supports the words fast and slow (e.g. SetTitleMatchMode, slow).  The default is fast, which is what AutoIt2 uses, whereas AutoIt3 uses the slow mode because it can “see” more text for certain windows.  The fast mode performs significantly better, which may help the speed of scripts that that do a lot of windowing commands.  The slow mode can be used to ensure full compatibility with AutoIt3 and its Window Spy (the Spy is included with AutoHotkey).  I’m thinking of modifying the Window Spy so that it indicates which text of a window is available only in the “slow” mode.<br>
<br>
Window finding reliability: Made the “slow” TitleMatchMode more reliable by increasing the timeout to 5 seconds because some windows are sluggish about checking their message queues (e.g. during long disk operations), and thus very slow to cough up their window text.<br>
<br>
In this version, by default, multiple instances of the same script can be launched.  If you wish to limit a script to a single instance, use the #SingleInstance directive described below.<br>
<br>
<br>
<b>ADDITIONS:</b><br>
DriveSpaceFree (gets the free space [in MB] for a drive).  Example:<br>
DriveSpaceFree, OutputVar, C:\<br>
<br>
SetAutoTrim, on/off (defaults to on): When you assign a value to a variable, this controls whether whitespace is automatically trimmed from the left and right of the string.  For this purpose, whitespace consists of spaces and tabs, but NOT newlines (carriage returns).  Thus, I believe the “on” setting yields the same behavior as AutoIt2 in this regard.<br>
<br>
StringGetPos now supports a new optional last param.  If that param is the letter R, the search will be conducted from the right instead of the left, i.e. the last occurrence will be found rather than the first.  ControlSetText: Derived from AutoIt3’s function of the same name.  Example:<br>
ControlSetText, ControlName, Some new text, wintitle, wintext, exclude-title, exclude-text<br>
<br>
Note that some or all of the last four params can be omitted.  If all of them are omitted, the window found by the most recent IfWinExist, IfWinNotExist, or WinWait will be used.  This behavior is the same for almost all of the other windowing commands too.<br>
<br>
#AllowSameLineComments: To increase compatibility with AutoIt2, scripts that end in .aut are normally not permitted to have same-line comments (e.g. Run, notepad  ; this is a comment).  Add the line #AllowSameLineComments to the top of your script to allow them.<br>
<br>
#SingleInstance: Specifying this anywhere in a script will prevent new instances of that script from being launched once there is already one running.  Instead, you will be prompted for whether to close the existing instance.  Note: You do not need to use “on” or “off” with this command.<br>
<br>
#CommentFlag: Allows you to change the comment-flag from the default of semicolon to a string of your choice.  The string can be up to 15 characters long.  Example: #CommentFlag //  ; Change to C++ style.<br>
<br>
#EscapeChar: The escape character is normally “`” but this allows you to change it to AutoIt2’s escape character (backslash) or some other char of your choice.  Note that by default, scripts that end in .aut will use the backslash for their escape char.<br>
<br>
#DerefChar: The deref char is normally % (e.g. Sleep, %SleepTime%).  You can change it to some other character with this.<br>
<br>
<br>
<b>TIPS<br></b>
The first comma can always be omitted for any command, e.g. MsgBox This is the text of the Msgbox (single-param mode).<br>
<br>
You can use the CapsLock keys as a new "modifier", similar to the windows key, without changing its native function (WinNT/2k/XP only, currently).  Example:<br>
CapsLock & A::run, notepad<br>
CapsLock & S::run, calc<br>


<br><hr><br>

</font><font size=4><b>0.207 BETA - November 12, 2003</b></font><font size=3><br><br>

Fixed StringMid: It was previously able to read beyond the length of the input variable.<br>
<br>
Disabled the auto-restore-on-resume feature -- which restores the foreground window that a suspended thread was working with -- because it probably causes more trouble than it's worth.<br>

<br><hr><br>

</font><font size=4><b>0.206 BETA - November 11, 2003</b></font><font size=3><br><br>


Fixed scripts randomly hanging (sleeping indefinitely): caused by the thread's main timer having been killed when it shouldn't be.<br>
<br>
Fixed WinWait-type commands that would behave unexpectedly if a new hotkey subroutine was launched while the command was waiting for the timeout to expire: the new subroutine was overwriting a buffer that was still needed by the old subroutine.<br>
<br>
Fixed: tray menu behaving strangely if a modal dialog, such as MsgBox or InputBox, was on the screen.<br>
<br>
Fixed the REPEAT command, which was causing an infinite loop if its first parameter was a dereferenced variable rather than a literal number.<br>

<br><hr><br>

</font><font size=4><b>0.205 BETA - November 10, 2003</b></font><font size=3><br><br>


Initial release 
 
<br><hr><br>
 
<a href="http://home.tampabay.rr.com/kodi/ahk/README.htm">Back to main page</a>

</body>
</html>
