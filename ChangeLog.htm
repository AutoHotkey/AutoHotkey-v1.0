<head>
<title>AutoHotkey Change Log</title>
</head>
<body>
<font size=5>AutoHotkey Change Log
<br>
<br>

</font><font size=4><b>0.212 BETA - December 8, 2003</b></font><font size=3><br><br>

Added support for a command being on the same line as its ELSE.  Examples:<br>
<PRE>
if x = 1
	Gosub, a1
else if x = 2
	Gosub, a2
else IfEqual, x, 3
{
	Gosub, a3
	Sleep, 1
}
else Gosub, a4  ; i.e. Any command can be on the same line with an ELSE.
 
;Also OK:
IfEqual, y, 1, Gosub, b1
else {
	Sleep, 1
	Gosub, b2
}
 
; But this is illegal:
if x = 1 {  ; Invalid: This would compare X to the string "1 {" instead of treating { as the start of a block.
	Sleep, 1
	MsgBox, test
}
 
; A legal alternative:
IfEqual, x, 1, {
	Sleep, 1
	MsgBox, test
}
</PRE>
 
The main use of the above is for "else if" ladders, which may increase the script's readability.<br>
<br>
<br>
Relaxed the conditions that triggered the warning dialog "More than X hotkeys have been received in the last Y milliseconds" (thanks to CyberSlug for the idea) so that keyboard auto-repeat feature can be used on most systems without triggering a warning.  In addition, you can customize this behavior by using the following directives:<br>
<br>
#HotkeyInterval 2000       ; This is the default value (milliseconds).<br>
#MaxHotkeysPerInterval 50  ; This is the default value.<br>
<br>
Care should be taken not to make the above too lenient because if you ever inadvertently introduce an infinite loop of keystrokes (via a Send command that accidentally triggers other hotkeys), your computer could become unresponsive due to the rapid flood of keyboard events.  Example of an infinite loop of keystrokes: ^c::Send, ^c<br>
<br>
If you want to do something like the above without triggering an infinite loop add a $ to the hotkey definition (e.g $#y::).  The $ tells it to use the hook for the hotkey, which is smart enough to know not to treat our own SEND commands as a source for hotkeys.  Using the hook has at least a couple of disadvantages, which is why it isn't always used: 1) Only one instance of the program at a time should have the hook installed; 2) It may very slightly impact system performance.<br>
<br>
<br>
Improved the ~ (tilde) hotkey prefix (see docs) so that it works with modified hotkeys (i.e. those that require CTRL, ALT, SHIFT, or WIN to be pressed) as well as unmodified ones.  The only exception is mouse buttons, which must be unmodified to be "non-suppressed".<br>
<br>
Made all windowing commands support the letter A as the first param to indicate that the active window should be used.  Even though the result is always "known" ahead of time for commands such as WinWait, WinActivate, IfWinExists, and IfWinActive (since by definition the active window is active and exists), this change makes things more consistent.  For example, the first param can conditionally resolve to the letter A at runtime, thus increasing flexibility.  In addition, this change also allows the Last Used Window to be reset easily such as in this example:
<PRE>
#y::  ; Win-Y
Run, notepad
WinWait, Notepad
WinActivate  ; Activate the window last found.
; ...Let's say some time has passed and we're no longer sure which window is the "last used" one.
WinActivate, Notepad
WinWait, a  ; ***** Set the "last used" window to be the active window.
; Now we can do commands such as the below without specifying the window (better performance too):
WinMinimize
ControlSend, , Some text that will appear in notepad even if it isn't active (ControlSend can use the "last used" window; in addition it sends to the top-most control by default).
WinMaximize
WinActivate
return
</PRE>
<br>
New command:<br>
#HotkeyModifierTimeout 100  ; value in milliseconds, default 100<br>
The above only has meaning if the script does not have the keyboard hook installed (you can see if your script uses the hook via the KeyLog command).  This is because the hook can keep track of which modifier keys (ALT/CTRL/WIN/SHIFT) the user is physically holding down.  Example:<br>
^!a::Send, abcdefg<br>
The above SEND requires that CTRL and ALT be released so that the keys get sent properly.  After the SEND completes, if the hook is installed the program knows whether it can safely push back down CTRL and ALT.  But if not and the SEND finishes more than HotkeyModifierTimeout milliseconds after the hotkey subroutine began, the modifier keys will not be restored and you will have to release and press them again if you wish to use them to modify the same (or another) key again.  Note: You can set the value to be -1 so that it never times out, or 0 so that it always times out.  Also, you can ensure that the keyboard hook is installed, thus making the above unnecessary, by adding the line #InstallKeybdHook anywhere in the script.  Reducing KeyDelay (via SetKeyDelay) to 0 or -1 may also help if the keyboard hook isn't installed, since SEND will run more quickly.<br>
<br>
Fixed unjustified warning dialog ("Another instance of this program already has the keyboard or mouse hook installed") that occurred sometimes when using the "Reload This Script" function.  This was apparently caused by OS being slow to unload the prior instance & mutex from memory.  The program now does not display this warning if a currently-running script is being restarted.<br>
<br>
Added $ as a hotkey modifier symbol (e.g. $^c): It results in the use of an alternate (more powerful) method to implement the hotkey.  Use this if the default method doesn't work properly (due to its recursive use of the Send command, for example).  In technical terms, this method uses the keyboard hook rather than RegisterHotkey() to implement the hotkey.<br>
<br> 
Fixed GetKeyState so that all keys work.  Previously, keys with NumPad equivalents, such as Delete and End, didn't work.<br>
<br>
GetKeyState now supports an optional 3rd arg that can be the letter T (state of toggleable key such as CapsLock) or P (physical state of key).  If the arg is omitted or blank, the logical state of the key will be returned.  The logical state should be one that the OS and the foreground app believe the key to be in, whereas the physical state is whether the key or mouse button is physically down or up.  Example:<br>
GetKeyState, state, CapsLock, T  ; Will set "state" to be D if CapsLock is ON or U otherwise.<br>
<br>
Currently the "physical" state is always the same as the logical state if the hooks aren't installed, because Windows XP (and probably NT/2k, but perhaps not Win9x) doesn't seem to properly implement the following code.  If anyone has a workaround, I'd love to hear it:<br>
#define IsPhysicallyDown(vk) (GetAsyncKeyState(vk) & 0x80000000)<br>
<br> 
The keyboard hook is installed to support left/right-modifier specific hotkeys, wildcard hotkeys, SetNum/Scroll/CapsLock, AlwaysOn/Off, to override Windows Explorer hotkeys such as Win-E, and for a few other purposes.  It is not unconditionally installed because it very slightly impacts system performance and is also only not designed to be used by more than one script at a time (though you can force it).  You can determine which  hooks (mouse and keyboard) are installed by assigning the KeyLog command to a hotkey.<br>
<br>
You can force the hooks to be installed unconditionally by adding either or both of these lines anywhere in the script:<br>
#InstallKeybdHook  ; this is the hook needed to maximize reliability of modifier restoration with the Send command (see above)<br>
#InstallMouseHook  ; this would probably only be used if you wanted to see mouse button events in the KeyLog, since it will automatically be installed if you are using any mouse hotkeys<br>
<br>
<br>
For the Send command, changed the name of ControlDown/Up to CtrlDown/Up so that it matches AutoIt.  Also added LCtrl and RCtrl as alternate valid key names for LControl/RControl for use with hotkeys as well as commands such as Send and GetKeyState.<br>
<br>
Fixed SEND so that if modifier keys are sent that happen to be part of the hotkey definition itself, those modifiers are restored after the Send is complete.  This resolves issues where if KeyDelay was greater than -1, you would have to release the modifiers and press them down again to get the same hotkey to fire again after the first time. Example:<br>
^+0::Send, {SHIFTDOWN}a{SHIFTUP}<br>
Another thanks to CyberSlug for discovering this problem.  See other sections above for further details.<br>
<br>
Changed ControlSend so that {ASC nnnn} items are ignored, since the OS does not support this feature when sending keystrokes directly to a window or control.<br>
<br>
Fixed the Send command, which was sometimes sending an incorrect scan code (usually inconsequential).<br>
<br>
Minor change: A modifier's key-up hotkey action (if it has one) won't fire if that modifier was used to modify any mouse button click (since Ctrl-LeftClick, for example, is a valid native OS feature that most users would never want to sacrifice).<br>
<br>
Minor change: Escape characters that occur at the very end of a line or that "escape" a whitespace character are now considered to be literal.  This should be more like AutoIt2.  Example:<br>
var1 = this character is now literal -->`<br>
<br>
Tip: C-style section comments can be used, but the symbols must appear at the beginning of a line to be recognized:<br>
/*<br>
...<br>
(section that is commented out)<br>
...<br>
*/<br>


<br><hr><br>
 
</font><font size=4><b>0.211 BETA - December 1, 2003</b></font><font size=3><br><br>
 
Fixed the Reload command and the corresponding tray menu item to work with script filenames that contain spaces.<br>
<br>
Added GetKeyState.  Example:<br>
GetKeyState, OutputVar, LButton<br>
It sets OutputVar to be U (for up), D (for down), or blank if the state couldn't be determined for any reason.
The key name can be virtually any of the keys listed in the documentation, including mouse buttons (at least under WinXP, and they will probably work on other OSes as well).<br>
<br>
Added a new optional param to MouseClick.  If this last param is D the button will be held down until it is released by the user physically clicking it or via another action in the script.  If this last param is U, the button will be released (even if it wasn't down before, an up-event will still be sent).<br>
<br>
Added new hotkey definition symbol ~ (tilde) to indicate that this hotkey's native function shouldn't be suppressed (hidden from the system) when the hotkey fires.  For example, in the below, the mouse button click will be sent to the active window when it normally wouldn't be:<br>
~RButton::Sleep, 1<br>
Note: Special hotkeys that are substitutes for alt-tab always ignore this setting.<br>
<br>
Changed commands that click the mouse (MouseClick, LeftClick, etc.) so that the clicks themselves cannot trigger hotkey subroutines.  This prevents potential infinite loop conditions if a script were to send mouse events that happen to be valid hotkeys.<br>
<br>
Changed slightly how hotkeys that are combinations of keyboard and mouse work: Normally if the prefix key of that pair modifies any other key (even something that isn't a hotkey) its key-up action won't fire (if it has one).  This has been changed so that mouse buttons are the exception.  For example:<br>
Numpad0 & Numpad1::MsgBox, test1  ; Numpad0 is now a prefix key that is handled by the keyboard hook.<br>
Numpad0::MsgBox, test2 ; Now Numpad0 is both a prefix AND a suffix (a suffix because it has its own action)<br>
Under the old method, if Numpad0 was pressed down and then a mouse button clicked, the Numpad0 action would not fire when Numpad0 is released, as it normally would.  Under the new method it does, but only if the combination of Numpad0 and that mouse button isn't a hotkey (since by default, the key/mouse events that comprise a hotkey are always hidden from the system unless the ~ symbol, described above, is used).<br>
 
 
<br><hr><br>

</font><font size=4><b>0.210 BETA - November 19, 2003</b></font><font size=3><br><br>

Added command "suspend".  It's just like the tray menu item of the same name.  The first param can be either blank (to toggle the state to the opposite setting), ON (to suspend hotkeys), or OFF (to resume).  Note: Any hotkey whose subroutine's first line is the "suspend" command will not be subject to suspension.  This allows any such hotkey to turn off the suspension.<br>
 
<br><hr><br>

</font><font size=4><b>0.209 BETA - November 19, 2003</b></font><font size=3><br><br>

Improved Run and RunWait so that they attempt CreateProcess() (the AutoIt method) if the normal ShellExecute() method fails to work.  This should make things more flexible and more like AutoIt.  Note: Internally, the ShellExecute() method is always attempted first because I believe it has more capabilities, such as the ability to run documents, launch URLs, and execute system verbs such as "properties" (see below).<br>
 
Run and RunWait now support the following system verbs: properties, edit, print, find, explore, open, and print.  Example:<br>
Run, properties c:\autoexec.bat  ; Bring up the properties dialog for this file.<br>
Run, edit %A_SCRIPTFULLPATH%  ; Perform the associated "edit" action for this file (if it has one).<br>
<br>
Added #Delimiter command.  This can be used to change to the default (comma) delimiter, which is used to separate commands and params from each other.  Note: It cannot be a space, tab (since some editors replace tabs with spaces), or a char that it already in use for another special purpose.  Example:<br>
#delimiter . ; Make the delimiter a period rather than a comma.<br>
<br>
Fixed tray menu item "Edit This Script" (again) because it still wasn’t working right.<br>
<br>
Enabled tray menu item "Suspend".  This function prevents new hotkey subroutines from launching (but Alt-Tab hotkeys will still work).  In other words, pressing a hotkey will have no effect at all; it won’t even be seen by the system.   For example, if Control-C is a hotkey, it would do nothing rather than its normal "copy" behavior.  Note: “Suspend” will not halt any subroutines that are already running.<br>
 
 
 
<br><hr><br>

</font><font size=4><b>0.208 BETA - November 17, 2003</b></font><font size=3><br><br>

<b>FIXES:</b><br>
Fixed the tray menu item "Edit This Script".<br>
<br>
Fixed compatibility-check for AutoIt2: some of the default AutoIt2 behaviors weren't being used.<br>
<br>
Fixed WinWait commands: Exclude-Text and Exclude-Title weren't being handled correctly.<br>
<br>
Turned off debug logging: If you were running an older version, you may have a small text file “C:\AutoHotkey SetForegroundWindowEx.txt”, which you can safely delete after upgrading to this version.<br>
<br>
Changed StringReplace so that it doesn't trim whitespace from the result, which matches AutoIt2's behavior.<br>
<br>
<br>
<b>CHANGES:</b><br>
Included the VC++ project in the source code ZIP file.<br>
<br>
Changed the default for .aut (AutoIt2) scripts to "DetectHiddenWindows, off", so that things are more like AutoIt2.  This is now the default for all scripts.  From what I can tell, unlike AutoIt2, AutoIt3 always detects hidden windows.  Since this can sometimes cause problems with window matching and distinctness, the AutoIt2 method seems to be a better default.<br>
<br>
Changed the SetTitleMatchMode command.  In addition to supporting the traditional modes of 1 & 2, the command now supports the words fast and slow (e.g. SetTitleMatchMode, slow).  The default is fast, which is what AutoIt2 uses, whereas AutoIt3 uses the slow mode because it can “see” more text for certain windows.  The fast mode performs significantly better, which may help the speed of scripts that that do a lot of windowing commands.  The slow mode can be used to ensure full compatibility with AutoIt3 and its Window Spy (the Spy is included with AutoHotkey).  I’m thinking of modifying the Window Spy so that it indicates which text of a window is available only in the “slow” mode.<br>
<br>
Window finding reliability: Made the “slow” TitleMatchMode more reliable by increasing the timeout to 5 seconds because some windows are sluggish about checking their message queues (e.g. during long disk operations), and thus very slow to cough up their window text.<br>
<br>
In this version, by default, multiple instances of the same script can be launched.  If you wish to limit a script to a single instance, use the #SingleInstance directive described below.<br>
<br>
<br>
<b>ADDITIONS:</b><br>
DriveSpaceFree (gets the free space [in MB] for a drive).  Example:<br>
DriveSpaceFree, OutputVar, C:\<br>
<br>
SetAutoTrim, on/off (defaults to on): When you assign a value to a variable, this controls whether whitespace is automatically trimmed from the left and right of the string.  For this purpose, whitespace consists of spaces and tabs, but NOT newlines (carriage returns).  Thus, I believe the “on” setting yields the same behavior as AutoIt2 in this regard.<br>
<br>
StringGetPos now supports a new optional last param.  If that param is the letter R, the search will be conducted from the right instead of the left, i.e. the last occurrence will be found rather than the first.  ControlSetText: Derived from AutoIt3’s function of the same name.  Example:<br>
ControlSetText, ControlName, Some new text, wintitle, wintext, exclude-title, exclude-text<br>
<br>
Note that some or all of the last four params can be omitted.  If all of them are omitted, the window found by the most recent IfWinExist, IfWinNotExist, or WinWait will be used.  This behavior is the same for almost all of the other windowing commands too.<br>
<br>
#AllowSameLineComments: To increase compatibility with AutoIt2, scripts that end in .aut are normally not permitted to have same-line comments (e.g. Run, notepad  ; this is a comment).  Add the line #AllowSameLineComments to the top of your script to allow them.<br>
<br>
#SingleInstance: Specifying this anywhere in a script will prevent new instances of that script from being launched once there is already one running.  Instead, you will be prompted for whether to close the existing instance.  Note: You do not need to use “on” or “off” with this command.<br>
<br>
#CommentFlag: Allows you to change the comment-flag from the default of semicolon to a string of your choice.  The string can be up to 15 characters long.  Example: #CommentFlag //  ; Change to C++ style.<br>
<br>
#EscapeChar: The escape character is normally “`” but this allows you to change it to AutoIt2’s escape character (backslash) or some other char of your choice.  Note that by default, scripts that end in .aut will use the backslash for their escape char.<br>
<br>
#DerefChar: The deref char is normally % (e.g. Sleep, %SleepTime%).  You can change it to some other character with this.<br>
<br>
<br>
<b>TIPS<br></b>
The first comma can always be omitted for any command, e.g. MsgBox This is the text of the Msgbox (single-param mode).<br>
<br>
You can use the CapsLock keys as a new "modifier", similar to the windows key, without changing its native function (WinNT/2k/XP only, currently).  Example:<br>
CapsLock & A::run, notepad<br>
CapsLock & S::run, calc<br>


<br><hr><br>

</font><font size=4><b>0.207 BETA - November 12, 2003</b></font><font size=3><br><br>

Fixed StringMid: It was previously able to read beyond the length of the input variable.<br>
<br>
Disabled the auto-restore-on-resume feature -- which restores the foreground window that a suspended thread was working with -- because it probably causes more trouble than it's worth.<br>

<br><hr><br>

</font><font size=4><b>0.206 BETA - November 11, 2003</b></font><font size=3><br><br>


Fixed scripts randomly hanging (sleeping indefinitely): caused by the thread's main timer having been killed when it shouldn't be.<br>
<br>
Fixed WinWait-type commands that would behave unexpectedly if a new hotkey subroutine was launched while the command was waiting for the timeout to expire: the new subroutine was overwriting a buffer that was still needed by the old subroutine.<br>
<br>
Fixed: tray menu behaving strangely if a modal dialog, such as MsgBox or InputBox, was on the screen.<br>
<br>
Fixed the REPEAT command, which was causing an infinite loop if its first parameter was a dereferenced variable rather than a literal number.<br>

<br><hr><br>

</font><font size=4><b>0.205 BETA - November 10, 2003</b></font><font size=3><br><br>


Initial release 
 
<br><hr><br>
 
<a href="http://home.tampabay.rr.com/kodi/ahk/README.htm">Back to main page</a>

</body>
</html>
